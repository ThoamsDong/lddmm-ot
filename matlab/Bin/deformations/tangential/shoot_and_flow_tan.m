function [points_evol,obj_evol,mom_evol] = shoot_and_flow_tan(points,mom,defo,obj)
% [points_evol,obj_evol,mom_evol] = SHOOT_AND_FLOW(points_init,mom_init,defo,obj) computes the evolution of
% obj under the deformation generated by the couple points/momentums via the Hamiltonian dynamics.
%
% Input :
%  points_init : initial coordinates of the points (position) in a (n x d) matrix.
%  mom_init : initial momentums in a (n x d) matrix.
%  defo : structure containing the parameters of deformations (kernel_size_mom,method,nstep,...)
%  obj : initial coordinate of the object to be flown (if not set, assume obj = x)
%
% Output
%  points_evol : a cell list containing evolution path of positions ( points_evol{i} is a n x d matrix and i ranges from 1 to defo_options.nstep+1)
%  obj_evol : a cell list containing evolution path of object ( obj_evol{i} is a n x d matrix and i ranges from 1 to defo_options.nstep+1)
%  mom_evol : a cell list containing evolution path of momentums ( p_evol{i} is a n x d matrix and i ranges from 1 to defo_options.nstep+1)
% Author : B. Charlier (2017)


[points_evol,mom_evol] = forward_tan(points,mom,defo);

if nargin==4 
	obj_evol = flow(obj,points_evol,mom_evol,defo);
else
	obj_evol =points_evol;
end

end


function [obj_evol] = flow(obj,x,p,defo)
% computes the evolution of the obj under the flow generated by x/p.

h = 1 ./ defo.nb_euler_steps;

switch defo.method
	case 'cuda'
		eulerStep = @euler_cuda;
	case 'matlab'
		eulerStep = @euler_mat;
	case 'grid'
		eulerStep = @euler_grid;
end

obj_evol= cell(1,defo.nb_euler_steps +1);
obj_evol{1} = obj;

for i = 1:defo.nb_euler_steps
    % Midpoint method 
    obj1 = eulerStep(x{i},p{i},obj_evol{i},defo,h/2);
    obj2 = eulerStep((x{i}+x{i+1})/2,(p{i} + p{i+1})/2,obj1,defo,h);

	obj_evol{i+1} = obj2 - obj1 + obj_evol{i};
end
    
end

function [nobj] = euler_cuda(x,p,obj,defo,h)
% This function implements an elementary Euler Step in cuda
nobj = obj;
for lam = defo.kernel_size_mom
    nobj = nobj + h * GaussGpuConv(obj',x',p',lam)';
end

end

function [nobj] = euler_mat(x,p,obj,defo,h)
% This function implements an elementary Euler Step in cuda

[nx,d]=size(x);
[ny,~]=size(obj);

% Calcul de A=exp(-|x_i -x_j|^2/(lam^2))
S=zeros(ny,nx);
for l=1:d
    S=S+(repmat(obj(:,l),1,nx)-repmat(x(:,l)',ny,1)).^2;
end
A = rho(S,0,defo.kernel_size_mom);

nobj = obj + h * A*p;

end

function [nobj] = euler_grid(x,p,obj,defo,h)
% This function implements an elementary Euler Step in cuda

%generate grid
bbox.min = min([x;obj],[],1)';bbox.max= max([x;obj],[],1)';
do_grad=0;do_gradgrad=0;
if ~isfield(defo,'sourcegrid')
    newGrid =1;
else 
    newGrid = changegrid(bbox.min,bbox.max,defo.kernel_size_mom,defo.gridratio,defo.sourcegrid);
end

if newGrid
    sourcegrid = setgrid(bbox,defo.kernel_size_mom,defo.gridratio,do_grad,do_gradgrad);
else
    sourcegrid =defo.sourcegrid;
end

nobj = obj;
for t = 1:size(sourcegrid.pas,2)
    nobj = nobj + h* gridOptimNew(x',p',obj',sourcegrid.long(:,t)',sourcegrid.pas(:,t),sourcegrid.origine(:,t),sourcegrid.fft3k_d{t},0)';
end

end
